# Wythoff博弈

## 例题：（POJ 1067）

有两堆石子，数量任意，可以不同。游戏开始由两个人轮流取石子。游戏规定，每次有两种不同的取法，一是可以在任意的一堆中取走任意多的石子；二是可以在两堆中同时取走相同数量的石子。最后把石子全部取完者为胜者。现在给出初始的两堆石子的数目，如果轮到你先取，假设双方都采取最好的策略，问最后你是胜者还是败者。

### Input

输入包含若干行，表示若干种石子的初始情况，其中每一行包含两个非负整数a和b，表示两堆石子的数目，a和b都不大于1,000,000,000。

### Output

输出对应也有若干行，每行包含一个数字1或0，如果最后你是胜者，则为1，反之，则为0。

### Sample Input

```
2 1
8 4
4 7
```

### Sample Output

```
0
1
0
```

## 解题思路

这一题从题目中就可以知道这是关于威佐夫博弈的问题，两人轮流从某一堆或者同时从两堆中取出同样多的物品，这样的问题我们称之为威佐夫博弈，关于威佐夫博弈的具体证明很难，我姑且在此放上一些blog上的见解，代日后仔细探索。

>这种情况下是颇为复杂的。我们用（ak，bk）（ak ≤ bk ,k=0，1，2，...,n)表示两堆物品的数量并称其为局势，如果甲面对（0，0），那么甲已经输了，这种局势我们称为奇异局势。前几个奇异局势是：（0，0）、（1，2）、（3，5）、（4，7）、（6，10）、（8，13）、（9，15）、（11，18）、（12，20）。
>    可以看出,a0=b0=0,ak是未在前面出现过的最小自然数,而 bk= ak + k，奇异局势有
>如下三条性质：
>    1。任何自然数都包含在一个且仅有一个奇异局势中。
>    由于ak是未在前面出现过的最小自然数，所以有ak > ak-1 ，而 bk= ak + k > ak-1 + k-1 = bk-1 > ak-1 。所以性质1。成立。
>    2。任意操作都可将奇异局势变为非奇异局势。
>    事实上，若只改变奇异局势（ak，bk）的某一个分量，那么另一个分量不可能在其他奇异局势中，所以必然是非奇异局势。如果使（ak，bk）的两个分量同时减少，则由于其差不变，且不可能是其他奇异局势的差，因此也是非奇异局势。
>    3。采用适当的方法，可以将非奇异局势变为奇异局势。
>
>    假设面对的局势是（a,b），若 b = a，则同时从两堆中取走 a 个物体，就变为了奇异局势（0，0）；如果a = ak ，b > bk，那么，取走b - bk个物体，即变为奇异局势；如果 a = ak ， b < bk ,则同时从两堆中拿走 ak - ab - ak个物体,变为奇异局势（ ab - ak , ab - ak+ b - ak）；如果a > ak ，b= ak + k,则从第一堆中拿走多余的数量a - ak 即可；如果a < ak ，b= ak + k,分两种情况，第一种，a=aj （j < k）,从第二堆里面拿走 b - bj 即可；第二种，a=bj （j < k）,从第二堆里面拿走 b - aj 即可。

**因此我们不管这些证明，我直接给出对付威佐夫博弈的公式**

```c++
int k = abs(a - b);
int n = (int)(k) * (1 + sqrt(5)) / 2;
if (n == min(a,b)) {
  printf("0\n");
} else {
  printf("1\n");   
}
```

